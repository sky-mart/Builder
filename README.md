# Builder

Разберусь наконец с тем, как происходит сборка проектов, что такое статические и динамические библиотеки, и какие есть инструменты для автоматизации сборки.


1. Когда вся программа состоит из одного файла, скомпилировать и скомпоновать проект можно одной командой

gcc file_name

Результат будет находиться в файле a.out, который запускается как и все исполняемые файлы

./a.out

Чтобы имя исполняемого файла было prog_name, нужно дописать

gcc file_name -o prog_name

Насколько я понимаю, -o -- значит output.

Запускать мы, соответсвенно, будем

./prog_name

Иногда, по умолчанию, файл создается неисполняемый, тогда системе нужно дополнительно указать на это

chmod +x prog_name


2. В упрощенном варианте процесс сборки состоит из этапов компиляции и компоновки. Команда из пункта 1 объединяет оба этапа и выдает исполняемый файл. Этапы можно выполнить раздельно. К примеру,

gcc -c file.c

скомпилирует файл file.c и создаст объектный файл file.o, в котором уже будет лежать машинный код, а

gcc file.o -o prog_name

скомпонует объектный файл file.o с другими объектными файлам, в нашем простом примере с системными библиотеками. GCC производит компоновку тогда, когда входной файл имеет расширение .o.


3. Если проект состоит из нескольких файлов, то можно указать их все

gcc file1.c file2.c header.h

На моей системе (clang apple llwm), к сожалению нельзя указать имя исполняемого файла.

Можно отдельно провести компиляцию всех исходников, а потом скомпоновать их все вместе. В случае изменений в одном файле, не нужно будет перекомпилировать остальные.

gcc -c file1.c
gcc -c file2.c
gcc file1.o file2.o header.h
